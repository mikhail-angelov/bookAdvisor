import { QdrantClient } from '@qdrant/js-client-rest';

export const qdrant = new QdrantClient({
  url: process.env.QDRANT_URL || 'http://127.0.0.1:6333',
});

export const COLLECTION_NAME = 'books';

// Note: Ensure the vector size matches the size generated by the exact DeepSeek embedding model.
// Common sizes are 1536 (OpenAI, some deepseek), etc. We will need to conform to DeepSeek's size.
// deepseek usually is 1024 or 1536, let's configure dynamically or set large.
// We'll set the size dynamically if the collection doesn't exist, but typically we must know it.
// Deepseek doesn't currently offer a public standalone embeddings API that isn't compatible with OpenAI size, but let's assume it's standard or we'll get it from the first batch.

export async function initCollection(vectorSize: number) {
  try {
    const collections = await qdrant.getCollections();
    const exists = collections.collections.find((c) => c.name === COLLECTION_NAME);

    if (!exists) {
      await qdrant.createCollection(COLLECTION_NAME, {
        vectors: {
          size: vectorSize,
          distance: 'Cosine',
        },
      });
      console.log(`Collection ${COLLECTION_NAME} created successfully.`);
    }
  } catch (error) {
    console.error('Error initializing Qdrant collection:', error);
  }
}

export interface BookPoint {
  id: string;      // Book ID (string from sqlite)
  vector: number[];
  payload: Record<string, unknown>;
}

export async function upsertBooks(points: BookPoint[]) {
  // Convert standard book IDs into qdrant-compatible UUIDs or integers.
  // Since our sqlite IDs might be UUIDs already (string), we map them to id.
  // If they are not valid UUIDs, we might need a deterministic hash or qdrant will reject.
  await qdrant.upsert(COLLECTION_NAME, {
    wait: true,
    points: points,
  });
}

export async function searchSimilar(vector: number[], limit: number = 10, excludeIds: string[] = []) {
  // Search similar vectors, optionally excluding a list of book IDs
  const filter = excludeIds.length > 0 ? {
    must_not: [
      {
        has_id: excludeIds
      }
    ]
  } : undefined;

  const results = await qdrant.search(COLLECTION_NAME, {
    vector,
    limit,
    filter,
    with_payload: true,
  });

  return results;
}

export async function retrieveVectors(ids: string[]): Promise<number[][]> {
  const points = await qdrant.retrieve(COLLECTION_NAME, {
    ids,
    with_vector: true,
  });
  
  // Qdrant returns vectors either as array of numbers or named vectors. We assume anonymous default vector here.
  return points.map(p => Array.isArray(p.vector) ? p.vector : (p.vector as any)?.[''] || []);
}
